package main

import (
	"encoding/json"
	"log"
	"net/http"
	"strings"

	"github.com/gorilla/mux"
	httpSwagger "github.com/swaggo/http-swagger/v2" // Corrected import alias

	// Ensure your project's Go module path is correct here
	_ "github.com/graceevelyns/Tubes2_BE_ian/src/cmd/docs" // Make sure docs are generated and included
	"github.com/graceevelyns/Tubes2_BE_ian/src/cmd/internal/algorithm"
	"github.com/graceevelyns/Tubes2_BE_ian/src/cmd/internal/api"
	"github.com/graceevelyns/Tubes2_BE_ian/src/cmd/internal/scraper"
)

var (
	processedGraphData []*scraper.Element
	elementNameToID    map[string]int
	elementIDToName    map[int]string
	router             *mux.Router // Global router variable
)

// Initializes maps for quick lookup between element names and IDs.
func initializeElementMaps(elements []*scraper.Element) {
	elementNameToID = make(map[string]int)
	elementIDToName = make(map[int]string)
	for _, el := range elements {
		// Normalize names to lowercase for case-insensitive lookup
		normalizedName := strings.ToLower(el.Name)
		elementNameToID[normalizedName] = el.ID
		elementIDToName[el.ID] = el.Name
	}
	log.Printf("Initialized %d element name/ID mappings.", len(elements))
}

// Initializes all necessary data and sets up the router.
// This function runs once when the serverless function initializes.
func initialize() {
	log.SetFlags(log.LstdFlags | log.Lshortfile)
	var err error

	// Fetch and process data during initialization
	log.Println("Fetching and processing graph data...")
	processedGraphData, err = scraper.FetchAndProcessData()
	if err != nil {
		// Log fatal will stop the initialization, preventing the function from serving requests
		log.Fatalf("FATAL: Failed to fetch/process initial graph data: %v", err)
	}
	if processedGraphData == nil || len(processedGraphData) == 0 {
		log.Fatalf("FATAL: Initial graph data is invalid or empty after processing.")
	}
	log.Printf("Successfully processed %d elements.", len(processedGraphData))

	// Initialize lookup maps
	initializeElementMaps(processedGraphData)

	// Initialize algorithm components with the processed data
	algorithm.InitializeAlgorithmElements(scraper.GetProcessedElements())
	log.Println("Algorithm components initialized.")

	// Create the handler for solving recipes
	solveRecipeHandler := api.NewSolveHandler(elementNameToID, elementIDToName)

	// Create and configure the main router
	router = mux.NewRouter()

	// --- IMPORTANT: Remove the Go CORS middleware ---
	// Vercel handles CORS via vercel.json headers configuration.
	// r.Use(func(next http.Handler) http.Handler { ... }) // REMOVED

	// --- Define API Routes ---

	// Swagger documentation route
	// Make sure the 'docs' directory generated by swag init is present.
	router.PathPrefix("/swagger/").Handler(httpSwagger.WrapHandler)
	log.Println("Swagger UI route configured at /swagger/")

	// Route to serve the processed graph data
	router.HandleFunc("/graph-data", serveGraphDataHandler).Methods(http.MethodGet)
	log.Println("Graph data route configured at /graph-data")

	// Route to handle recipe solving requests
	router.Handle("/solve-recipe", solveRecipeHandler).Methods(http.MethodGet) // Use Handle for http.Handler
	log.Println("Solve recipe route configured at /solve-recipe")

	log.Println("Initialization complete. Router is configured.")
}

// The main entry point for the application.
// It initializes the application state and router.
func main() {
	// Initialize the application (data scraping, router setup)
	initialize()

	// --- IMPORTANT: Remove the ListenAndServe call ---
	// Vercel manages the server lifecycle. We just need to have the router ready.
	// The Vercel Go runtime will likely look for a default handler or use the setup
	// implicitly when running the compiled binary.
	// log.Printf("API server ready...") // Log message indicating readiness
	// if err := http.ListenAndServe(":"+port, router); err != nil { // REMOVED
	// 	log.Fatalf("error: %v", err)
	// }

	// In a typical Vercel setup with main.go, the compiled binary itself
	// needs to implicitly serve http using the configured router.
	// Often, this means the Vercel Go runtime expects `http.DefaultServeMux`
	// or requires a specific handler export.
	// For simplicity with `mux`, we can make our router the default handler.
	// Note: This might need adjustment based on the specifics of how `@vercel/go`
	// handles custom `main.go` files vs the standard `api/` directory structure.
	// If deployment still fails, consider switching to the `api/index.go` pattern.
	log.Println("Application initialized. Vercel runtime will handle requests.")
	http.Handle("/", router) // Make our router handle all incoming requests via the default ServeMux

	// Vercel will start the server listening part. We don't call ListenAndServe.
}

// serveGraphDataHandler serves the pre-processed graph data as JSON.
// Swagger annotations remain the same.
//
//	@Summary      Get All Processed Graph Data
//	@Description  For testing purposes, this endpoint returns all processed graph data in JSON format
//	@Tags         Graph Data
//	@Produce      json
//	@Success      200 {array}   scraper.Element "Array element data in JSON format"
//	@Failure      500 {string}  string          "Error if graph data is not ready or invalid"
//	@Router       /graph-data [get]
func serveGraphDataHandler(w http.ResponseWriter, r *http.Request) {
	// Check if data is available (it should be after initialize)
	if processedGraphData == nil || len(processedGraphData) == 0 {
		log.Println("ERROR /graph-data: processedGraphData is nil or empty despite initialization.")
		http.Error(w, "Internal Server Error: Graph data is not available.", http.StatusInternalServerError)
		return
	}

	log.Printf("Serving /graph-data request with %d elements.", len(processedGraphData))

	w.Header().Set("Content-Type", "application/json")
	if err := json.NewEncoder(w).Encode(processedGraphData); err != nil {
		log.Printf("ERROR /graph-data: Failed to encode graph data to JSON: %v", err)
		http.Error(w, "Internal Server Error: Failed to format graph data.", http.StatusInternalServerError)
	}
}

